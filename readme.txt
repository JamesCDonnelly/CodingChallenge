Thanks, I had a lot of fun putting this together. 
Reasoning for the scenario
This application was designed as a text-based adventure type scenario that sees the user create creatures using the machine they discover. From a technical point of view, it generates responses based on a series of conditions the user can alter and records those as objects in a list which can then be read.
It wasn’t initially so morbid but as the application developed, I added more horror elements to the mix, using words that were designed to invoke disturbing imagery and deliberately vague descriptions, thereby letting the user fill in the blanks as to why and that they were experiencing. I also shifted the perspective from first person to second person perspective, that way you are interacting via the protagonist rather than yourself, in an attempt to to try and remove any sense of control you might feel.
 I was heavily inspired in part by developer Yames who created games such as Discover My Body, The Well and Growing my Grandpa, as well as the generated stories and descriptions from Dwarf Fortress developed by Bay 12 Games. If you aren’t familiar with these, Yames produces games that fit into the ‘body horror’ genre of horror. They employ simplistic and stylized imagery and descriptive writing to employ a sense of creeping dread while letting the player fill in the gaps with their mind. While Dwarf fortress is a highly impressive tile-based fortress simulation that what lacks in graphics makes up for in generated and historically recorded descriptions for near everything that happens during play.
I could have gone for something more mathematically challenging such as tile-based games and layouts but I have programmed this many times in the past that to be honest I no longer consider it to be that interesting. For examples of my work on that you can check out Runmaster20, a unity prototype that employs only a single camera and light in the scene and builds everything else in C# scripts. Or RNMAST~1~v0.21.txt, included in this repo, a tile-based game prototype written in batch with NPC dialogue and unfinished battle system. 
Programming structure
The application is designed with a main class that runs methods via a choice system until returning a parameter to end the program.
The heart of the application would be the infostore class that stores objects in lists and allows these lists and data to be read by other methods and classes. I expect there is a better way of doing this but at this time I’m not sure of best practice. Some lists are auto populated when called in Main while others are modified during runtime.
The other classes of note are the Menagerie class and the Facility class.
The Menagerie class is essentially a class that reads an objects data from a list and presents it in a specific way. It also allows you to iterate through the list which loops back to the start once it reaches the end. 
The Facility class takes a user’s input and produces a set of data based on that input which is then used to select data from a number of enums and store them within an object. The object is then stored to a list.
One notable class is the ConsoleHelper class. This class wasn’t written by myself but copied from StackOverflow and modified. The class isn’t complicated but contains a rather nifty looking choice system, I employed it in both the Facility and Menagerie classes.

Lastly, I’d like to comment on the catalyst matrixes and values being set to 255 then converted into percentages. As I said previously, I’ve worked with matrixes quite a lot in the past for tile-based grids so I’m no stranger to them. And while I wasn’t making tile-based environments here I still wanted to show that I could work with matrixes, as such I felt that the datamap parameter I included for calculating how catalysts affect user input worked well, even if they designed was underutilized here. As for everything being written as a 255 integer, that was due to poor design, originally, I used bytes to hold my data as I didn’t need negative values and felt setting the gauges to a non-multiple of 10 would add to that deliberately vagueness I discussed previously. It was simple enough to convert to percentage when I needed to calculate something, unfortunately I forgot to take into account that a byte won’t stop at 0 but rather rollover when decrementing it. Instead of employing extra byte friendly code to clamp them to set values I decided early to recast everything to an int and use regular methods, but had to keep the 255 values due to the code I had already written. Ultimately it wasn’t a problem but if I was to rebuild this design, I would definitely just use a maximum of 100. 
 I’ve tried to keep code clean and concise, condensing methods and removing duplicate code where possible. I’m not great at employing the best information hiding and can be sure there are parameters that can be exploited but I don’t feel the end result is too bad, I’d love feedback and examples of how I could improve what I’ve written.

- It calls out with a bellowing laugh. -
